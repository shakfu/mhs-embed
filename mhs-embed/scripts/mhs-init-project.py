#!/usr/bin/env python3
"""
mhs-init-project.py - Initialize a new MicroHs project with FFI support

Creates all boilerplate files for a new MicroHs project that can be
embedded as a standalone binary using the lib/mhs-embed infrastructure.

Usage:
    ./mhs-embed/scripts/mhs-init-project.py my_project
    ./mhs-embed/scripts/mhs-init-project.py my_project --output-dir projects/my-project
    ./mhs-embed/scripts/mhs-init-project.py my_project --no-cmake

Generated files:
    <output-dir>/
        CMakeLists.txt           - CMake build configuration
        <project>_ffi.h          - C FFI header
        <project>_ffi.c          - C FFI implementation
        <project>_ffi_wrappers.c - MicroHs FFI wrappers
        <project>_main.c         - REPL entry point
        <project>_standalone_main.c - Standalone entry point
        lib/
            <Project>.hs         - Main Haskell module with FFI bindings
"""

import argparse
import os
import sys
from pathlib import Path
from datetime import datetime


def to_camel_case(snake_str: str) -> str:
    """Convert snake_case to CamelCase."""
    components = snake_str.split('_')
    return ''.join(x.title() for x in components)


def to_upper_snake(snake_str: str) -> str:
    """Convert snake_case to UPPER_SNAKE_CASE."""
    return snake_str.upper()


def generate_ffi_header(project_name: str) -> str:
    """Generate the C FFI header file."""
    upper = to_upper_snake(project_name)
    return f'''/* {project_name}_ffi.h - C FFI interface for {project_name}
 *
 * This header declares the C functions that will be called from Haskell
 * via the Foreign Function Interface (FFI).
 *
 * Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}
 */

#ifndef {upper}_FFI_H
#define {upper}_FFI_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {{
#endif

/* ========================================================================
 * Initialization and cleanup
 * ======================================================================== */

/* Initialize the {project_name} subsystem.
 * Returns 0 on success, non-zero on failure.
 */
int {project_name}_init(void);

/* Clean up resources. Call before program exit. */
void {project_name}_cleanup(void);

/* Get version string. */
const char* {project_name}_version(void);

/* ========================================================================
 * Example functions - replace with your actual API
 * ======================================================================== */

/* Process an integer value.
 * Returns the processed result.
 */
int {project_name}_process(int value);

/* Combine two values.
 * Returns the combined result.
 */
int {project_name}_combine(int a, int b);

/* Perform an action with the given parameter.
 * This is a void function example.
 */
void {project_name}_action(int param);

#ifdef __cplusplus
}}
#endif

#endif /* {upper}_FFI_H */
'''


def generate_ffi_impl(project_name: str) -> str:
    """Generate the C FFI implementation file."""
    return f'''/* {project_name}_ffi.c - C FFI implementation for {project_name}
 *
 * Implements the C functions declared in {project_name}_ffi.h
 *
 * Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}
 */

#include "{project_name}_ffi.h"
#include <stdio.h>
#include <string.h>

/* ========================================================================
 * Internal state
 * ======================================================================== */

static int g_initialized = 0;
static const char* VERSION = "0.1.0";

/* ========================================================================
 * Initialization and cleanup
 * ======================================================================== */

int {project_name}_init(void) {{
    if (g_initialized) {{
        return 0;  /* Already initialized */
    }}

    /* TODO: Add your initialization code here */
    printf("{project_name}: initialized\\n");

    g_initialized = 1;
    return 0;
}}

void {project_name}_cleanup(void) {{
    if (!g_initialized) {{
        return;
    }}

    /* TODO: Add your cleanup code here */
    printf("{project_name}: cleanup\\n");

    g_initialized = 0;
}}

const char* {project_name}_version(void) {{
    return VERSION;
}}

/* ========================================================================
 * Example functions - replace with your actual implementation
 * ======================================================================== */

int {project_name}_process(int value) {{
    /* TODO: Implement your processing logic */
    return value * 2;
}}

int {project_name}_combine(int a, int b) {{
    /* TODO: Implement your combination logic */
    return a + b;
}}

void {project_name}_action(int param) {{
    /* TODO: Implement your action */
    printf("{project_name}: action called with %d\\n", param);
}}
'''


def generate_ffi_wrappers(project_name: str) -> str:
    """Generate the MicroHs FFI wrappers file."""
    return f'''/* {project_name}_ffi_wrappers.c - MicroHs FFI wrappers for {project_name}
 *
 * These wrappers convert between MicroHs runtime stack representation
 * and C function calls, enabling the FFI to work in the REPL.
 *
 * Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}
 */

#include "mhsffi.h"
#include "{project_name}_ffi.h"

/* ========================================================================
 * 0-arity functions (no arguments)
 *
 * Stack layout: [] -> [result]
 * Result slot = arity = 0
 * ======================================================================== */

from_t mhs_{project_name}_init(int s) {{
    return mhs_from_Int(s, 0, {project_name}_init());
}}

from_t mhs_{project_name}_cleanup(int s) {{
    {project_name}_cleanup();
    return mhs_from_Unit(s, 0);
}}

from_t mhs_{project_name}_version(int s) {{
    return mhs_from_Ptr(s, 0, (void*){project_name}_version());
}}

/* ========================================================================
 * 1-arity functions (one argument)
 *
 * Stack layout: [arg0] -> [result]
 * arg0 at slot 0, result slot = arity = 1
 * ======================================================================== */

from_t mhs_{project_name}_process(int s) {{
    int arg = mhs_to_Int(s, 0);
    int result = {project_name}_process(arg);
    return mhs_from_Int(s, 1, result);
}}

from_t mhs_{project_name}_action(int s) {{
    int arg = mhs_to_Int(s, 0);
    {project_name}_action(arg);
    return mhs_from_Unit(s, 1);
}}

/* ========================================================================
 * 2-arity functions (two arguments)
 *
 * Stack layout: [arg0, arg1] -> [result]
 * arg0 at slot 0, arg1 at slot 1, result slot = arity = 2
 * ======================================================================== */

from_t mhs_{project_name}_combine(int s) {{
    int a = mhs_to_Int(s, 0);
    int b = mhs_to_Int(s, 1);
    int result = {project_name}_combine(a, b);
    return mhs_from_Int(s, 2, result);
}}

/* ========================================================================
 * FFI table
 *
 * Format: {{ "c_function_name", arity, wrapper_function }}
 *
 * The c_function_name must match the Haskell foreign import:
 *   foreign import ccall "{project_name}_ffi.h {project_name}_init"
 *       c_{project_name}_init :: IO CInt
 * ======================================================================== */

static const struct ffi_entry {project_name}_ffi_table[] = {{
    /* 0-arity */
    {{ "{project_name}_init",    0, mhs_{project_name}_init }},
    {{ "{project_name}_cleanup", 0, mhs_{project_name}_cleanup }},
    {{ "{project_name}_version", 0, mhs_{project_name}_version }},

    /* 1-arity */
    {{ "{project_name}_process", 1, mhs_{project_name}_process }},
    {{ "{project_name}_action",  1, mhs_{project_name}_action }},

    /* 2-arity */
    {{ "{project_name}_combine", 2, mhs_{project_name}_combine }},

    /* sentinel - MUST be last */
    {{ 0, 0, 0 }}
}};

/* Override xffi_table - provides our FFI to the MicroHs runtime */
const struct ffi_entry *xffi_table = {project_name}_ffi_table;
'''


def generate_repl_main(project_name: str) -> str:
    """Generate the REPL entry point."""
    camel = to_camel_case(project_name)
    return f'''/* {project_name}_main.c - Entry point for {project_name} REPL
 *
 * This provides the {project_name} binary that:
 * 1. Auto-detects MHSDIR if not set
 * 2. Auto-adds the project library include path
 * 3. Supports repl, compile, and run modes
 *
 * Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <direct.h>
#define PATH_MAX MAX_PATH
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#else
#include <unistd.h>
#include <libgen.h>
#endif

#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif

#ifdef __linux__
#include <linux/limits.h>
#endif

#ifndef PATH_MAX
#define PATH_MAX 4096
#endif

/* Forward declaration of MicroHs main */
int mhs_main(int argc, char **argv);

/* Get the directory containing the executable */
static int get_exe_dir(char *buf, size_t size) {{
#ifdef _WIN32
    DWORD len = GetModuleFileNameA(NULL, buf, (DWORD)size);
    if (len > 0 && len < size) {{
        char *last_sep = strrchr(buf, '\\\\');
        if (!last_sep) last_sep = strrchr(buf, '/');
        if (last_sep) {{
            *last_sep = '\\0';
            return 0;
        }}
    }}
#elif defined(__APPLE__)
    uint32_t bufsize = (uint32_t)size;
    if (_NSGetExecutablePath(buf, &bufsize) == 0) {{
        char *dir = dirname(buf);
        strncpy(buf, dir, size - 1);
        buf[size - 1] = '\\0';
        return 0;
    }}
#elif defined(__linux__)
    ssize_t len = readlink("/proc/self/exe", buf, size - 1);
    if (len > 0) {{
        buf[len] = '\\0';
        char *dir = dirname(buf);
        strncpy(buf, dir, size - 1);
        buf[size - 1] = '\\0';
        return 0;
    }}
#endif
    return -1;
}}

static int file_exists(const char *path) {{
    struct stat st;
    return stat(path, &st) == 0 && S_ISREG(st.st_mode);
}}

static char* resolve_path(const char *path) {{
#ifdef _WIN32
    char *resolved = malloc(PATH_MAX);
    if (resolved && _fullpath(resolved, path, PATH_MAX)) {{
        return resolved;
    }}
    free(resolved);
    return NULL;
#else
    return realpath(path, NULL);
#endif
}}

static int set_env(const char *name, const char *value) {{
#ifdef _WIN32
    return _putenv_s(name, value);
#else
    return setenv(name, value, 1);
#endif
}}

static int find_mhsdir(char *buf, size_t size, const char *exe_dir) {{
    const char *candidates[] = {{
        "../thirdparty/MicroHs",
        "../share/{project_name}/MicroHs",
        "../lib/{project_name}/MicroHs",
        NULL
    }};

    for (int i = 0; candidates[i]; i++) {{
        snprintf(buf, size, "%s/%s", exe_dir, candidates[i]);
        char prelude_path[PATH_MAX];
        snprintf(prelude_path, sizeof(prelude_path), "%s/lib/Prelude.hs", buf);

        if (file_exists(prelude_path)) {{
            char *resolved = resolve_path(buf);
            if (resolved) {{
                strncpy(buf, resolved, size - 1);
                buf[size - 1] = '\\0';
                free(resolved);
                return 0;
            }}
        }}
    }}
    return -1;
}}

static int find_project_lib(char *buf, size_t size, const char *exe_dir) {{
    const char *candidates[] = {{
        "../projects/{project_name}/lib",
        "../share/{project_name}/lib",
        "../lib/{project_name}/lib",
        NULL
    }};

    for (int i = 0; candidates[i]; i++) {{
        snprintf(buf, size, "%s/%s", exe_dir, candidates[i]);
        char module_path[PATH_MAX];
        snprintf(module_path, sizeof(module_path), "%s/{camel}.hs", buf);

        if (file_exists(module_path)) {{
            char *resolved = resolve_path(buf);
            if (resolved) {{
                strncpy(buf, resolved, size - 1);
                buf[size - 1] = '\\0';
                free(resolved);
                return 0;
            }}
        }}
    }}
    return -1;
}}

static void print_usage(const char *prog) {{
    printf("%s - MicroHs with {project_name} support\\n\\n", prog);
    printf("Usage:\\n");
    printf("  %s                     Start interactive REPL\\n", prog);
    printf("  %s [mhs-options]       Pass options to MicroHs\\n", prog);
    printf("  %s --help              Show this help\\n", prog);
    printf("\\nEnvironment:\\n");
    printf("  MHSDIR                 Path to MicroHs (auto-detected)\\n");
    printf("\\nExamples:\\n");
    printf("  %s                     Start REPL\\n", prog);
    printf("  %s -r MyFile.hs        Run a Haskell file\\n", prog);
    printf("  %s -oMyProg MyFile.hs  Compile to executable\\n", prog);
    printf("\\nAvailable modules: {camel}\\n");
}}

int main(int argc, char **argv) {{
    char exe_dir[PATH_MAX];
    char mhsdir[PATH_MAX];
    char project_lib[PATH_MAX];
    char include_arg[PATH_MAX + 3];

    if (argc >= 2 && (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0)) {{
        print_usage(argv[0]);
        return 0;
    }}

    if (get_exe_dir(exe_dir, sizeof(exe_dir)) != 0) {{
        fprintf(stderr, "Warning: Could not determine executable directory\\n");
        exe_dir[0] = '\\0';
    }}

    if (!getenv("MHSDIR")) {{
        if (exe_dir[0] && find_mhsdir(mhsdir, sizeof(mhsdir), exe_dir) == 0) {{
            set_env("MHSDIR", mhsdir);
        }} else {{
            fprintf(stderr, "Error: Cannot find MicroHs directory.\\n");
            fprintf(stderr, "Set MHSDIR environment variable.\\n");
            return 1;
        }}
    }}

    int have_project_lib = 0;
    if (exe_dir[0] && find_project_lib(project_lib, sizeof(project_lib), exe_dir) == 0) {{
        have_project_lib = 1;
        snprintf(include_arg, sizeof(include_arg), "-i%s", project_lib);
    }}

    int arg_offset = 0;
    if (argc >= 2 && strcmp(argv[1], "repl") == 0) {{
        arg_offset = 1;
    }}

    int extra_args = 1 + (have_project_lib ? 1 : 0);
    int new_argc = argc - arg_offset + extra_args;
    char **new_argv = malloc((new_argc + 1) * sizeof(char *));

    if (!new_argv) {{
        fprintf(stderr, "Error: Memory allocation failed\\n");
        return 1;
    }}

    int j = 0;
    new_argv[j++] = argv[0];
    new_argv[j++] = "-C";

    if (have_project_lib) {{
        new_argv[j++] = include_arg;
    }}

    for (int i = 1 + arg_offset; i < argc; i++) {{
        new_argv[j++] = argv[i];
    }}
    new_argv[j] = NULL;

    int result = mhs_main(new_argc, new_argv);
    free(new_argv);
    return result;
}}
'''


def generate_standalone_main(project_name: str) -> str:
    """Generate the standalone entry point."""
    camel = to_camel_case(project_name)
    return f'''/* {project_name}_standalone_main.c - Entry point for standalone {project_name}
 *
 * Self-contained binary with embedded MicroHs libraries via VFS.
 * Requires no external files (MHSDIR not needed).
 *
 * Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "vfs.h"

/* Forward declaration of MicroHs main */
int mhs_main(int argc, char **argv);

static void print_usage(const char *prog) {{
    printf("%s - Self-contained MicroHs with {project_name} support\\n\\n", prog);
    printf("Usage:\\n");
    printf("  %s                     Start interactive REPL\\n", prog);
    printf("  %s [mhs-options]       Pass options to MicroHs\\n", prog);
    printf("  %s --help              Show this help\\n", prog);
    printf("\\nExamples:\\n");
    printf("  %s                     Start REPL\\n", prog);
    printf("  %s -r MyFile.hs        Run a Haskell file\\n", prog);
    printf("  %s -oMyProg MyFile.hs  Compile to executable\\n", prog);
    printf("\\nAvailable modules: {camel}\\n");
}}

static int needs_extraction(int argc, char **argv) {{
    for (int i = 1; i < argc; i++) {{
        if (strncmp(argv[i], "-o", 2) == 0) {{
            const char *output = NULL;
            if (argv[i][2] != '\\0') {{
                output = argv[i] + 2;
            }} else if (i + 1 < argc) {{
                output = argv[i + 1];
            }}
            if (output) {{
                size_t len = strlen(output);
                if (len >= 2 && strcmp(output + len - 2, ".c") == 0) {{
                    return 0;
                }}
                return 1;
            }}
        }}
    }}
    return 0;
}}

int main(int argc, char **argv) {{
    char *temp_dir = NULL;
    int linking_libs = 0;

    if (argc >= 2 && (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0)) {{
        print_usage(argv[0]);
        return 0;
    }}

    vfs_init();

    if (needs_extraction(argc, argv)) {{
        temp_dir = vfs_extract_to_temp();
        if (!temp_dir) {{
            fprintf(stderr, "Error: Failed to extract embedded files\\n");
            return 1;
        }}
        setenv("MHSDIR", temp_dir, 1);
        linking_libs = 1;
    }} else {{
        setenv("MHSDIR", vfs_get_temp_dir(), 1);
    }}

    int arg_offset = 0;
    if (argc >= 2 && strcmp(argv[1], "repl") == 0) {{
        arg_offset = 1;
    }}

    /* TODO: Add linker flags for your libraries when linking_libs is true */
#ifdef VFS_USE_PKG
    #define PKG_EXTRA_ARGS 3
#else
    #define PKG_EXTRA_ARGS 0
#endif

    int extra_args = 1 + PKG_EXTRA_ARGS;
    int new_argc = argc - arg_offset + extra_args;
    char **new_argv = malloc((new_argc + 1) * sizeof(char *));

    if (!new_argv) {{
        fprintf(stderr, "Error: Memory allocation failed\\n");
        if (temp_dir) vfs_cleanup_temp(temp_dir);
        return 1;
    }}

    int j = 0;
    new_argv[j++] = argv[0];
    new_argv[j++] = "-C";

#ifdef VFS_USE_PKG
    new_argv[j++] = "-a/mhs-embedded";
    new_argv[j++] = "-pbase";
    new_argv[j++] = "-p{project_name}";
#endif

    /* TODO: Add -optl flags here if linking_libs && you have libraries */
    (void)linking_libs;

    for (int i = 1 + arg_offset; i < argc; i++) {{
        new_argv[j++] = argv[i];
    }}
    new_argv[j] = NULL;
    new_argc = j;

    int result = mhs_main(new_argc, new_argv);

    free(new_argv);
    if (temp_dir) {{
        vfs_cleanup_temp(temp_dir);
    }}

    return result;
}}
'''


def generate_haskell_module(project_name: str) -> str:
    """Generate the main Haskell module with FFI bindings."""
    camel = to_camel_case(project_name)
    return f'''-- | {camel} - Haskell bindings for {project_name}
--
-- This module provides Haskell bindings to the {project_name} C library.
--
-- Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}

module {camel}
    ( -- * Initialization
      init
    , cleanup
    , version

      -- * Core functions
    , process
    , combine
    , action
    ) where

import Prelude hiding (init)
import Foreign.C.Types
import Foreign.C.String

-- ============================================================================
-- FFI imports
-- ============================================================================

foreign import ccall "{project_name}_ffi.h {project_name}_init"
    c_{project_name}_init :: IO CInt

foreign import ccall "{project_name}_ffi.h {project_name}_cleanup"
    c_{project_name}_cleanup :: IO ()

foreign import ccall "{project_name}_ffi.h {project_name}_version"
    c_{project_name}_version :: IO CString

foreign import ccall "{project_name}_ffi.h {project_name}_process"
    c_{project_name}_process :: CInt -> IO CInt

foreign import ccall "{project_name}_ffi.h {project_name}_combine"
    c_{project_name}_combine :: CInt -> CInt -> IO CInt

foreign import ccall "{project_name}_ffi.h {project_name}_action"
    c_{project_name}_action :: CInt -> IO ()

-- ============================================================================
-- Haskell API
-- ============================================================================

-- | Initialize the {project_name} subsystem.
-- Returns True on success.
init :: IO Bool
init = do
    result <- c_{project_name}_init
    return (result == 0)

-- | Clean up resources. Call before program exit.
cleanup :: IO ()
cleanup = c_{project_name}_cleanup

-- | Get the version string.
version :: IO String
version = c_{project_name}_version >>= peekCString

-- | Process an integer value.
process :: Int -> IO Int
process x = fromIntegral <$> c_{project_name}_process (fromIntegral x)

-- | Combine two values.
combine :: Int -> Int -> IO Int
combine a b = fromIntegral <$> c_{project_name}_combine (fromIntegral a) (fromIntegral b)

-- | Perform an action with the given parameter.
action :: Int -> IO ()
action x = c_{project_name}_action (fromIntegral x)
'''


def generate_example_main(project_name: str) -> str:
    """Generate an example Haskell main program."""
    camel = to_camel_case(project_name)
    return f'''-- | Example program using {camel}
--
-- Run with: {project_name} -r examples/Main.hs

module Main where

import {camel}

main :: IO ()
main = do
    -- Initialize
    ok <- {camel}.init
    if ok
        then do
            -- Get version
            v <- {camel}.version
            putStrLn $ "{camel} version: " ++ v

            -- Use the API
            result <- {camel}.process 21
            putStrLn $ "process 21 = " ++ show result

            combined <- {camel}.combine 10 32
            putStrLn $ "combine 10 32 = " ++ show combined

            {camel}.action 42

            -- Cleanup
            {camel}.cleanup
        else
            putStrLn "Failed to initialize {camel}"
'''


def generate_cmake(project_name: str) -> str:
    """Generate CMakeLists.txt for the project."""
    camel = to_camel_case(project_name)
    upper = to_upper_snake(project_name)
    return f'''# CMakeLists.txt for {project_name}
# MicroHs project with FFI support
#
# Generated by mhs-init-project.py on {datetime.now().strftime("%Y-%m-%d")}

# ============================================
# Configuration
# ============================================

set(MHS_DIR ${{CMAKE_SOURCE_DIR}}/thirdparty/MicroHs)
set(MHS_RUNTIME ${{MHS_DIR}}/src/runtime)
set(MHS_LIB ${{MHS_DIR}}/lib)
set({upper}_LIB_DIR ${{CMAKE_CURRENT_SOURCE_DIR}}/lib)
set(MHS_EMBED_DIR ${{CMAKE_SOURCE_DIR}}/mhs-embed)

if(WIN32)
    set(MHS_COMPILER ${{MHS_DIR}}/bin/mhs.exe)
else()
    set(MHS_COMPILER ${{MHS_DIR}}/bin/mhs)
endif()

# Build MicroHs compiler if needed
if(NOT EXISTS ${{MHS_COMPILER}})
    message(STATUS "Building MicroHs compiler...")
    if(WIN32)
        execute_process(
            COMMAND nmake -f Makefile.windows
            WORKING_DIRECTORY ${{MHS_DIR}}
            RESULT_VARIABLE MHS_BUILD_RESULT
        )
    else()
        execute_process(
            COMMAND make
            WORKING_DIRECTORY ${{MHS_DIR}}
            RESULT_VARIABLE MHS_BUILD_RESULT
        )
    endif()
    if(NOT MHS_BUILD_RESULT EQUAL 0)
        message(FATAL_ERROR "Failed to build MicroHs compiler")
    endif()
endif()

# Python for patching scripts
find_package(Python3 REQUIRED COMPONENTS Interpreter)

# ============================================
# FFI Library
# ============================================

add_library({project_name}_ffi STATIC {project_name}_ffi.c)
target_include_directories({project_name}_ffi PUBLIC ${{CMAKE_CURRENT_SOURCE_DIR}})

# TODO: Add your library dependencies here
# target_link_libraries({project_name}_ffi PUBLIC your_library)

# ============================================
# {project_name} REPL (non-standalone)
# ============================================

# Patch mhs.c to remove xffi_table
add_custom_command(
    OUTPUT ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_repl.c
    COMMAND ${{Python3_EXECUTABLE}} ${{CMAKE_SOURCE_DIR}}/mhs-embed/scripts/mhs-patch-xffi.py
        ${{MHS_DIR}}/generated/mhs.c
        ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_repl.c
    DEPENDS ${{MHS_DIR}}/generated/mhs.c ${{CMAKE_SOURCE_DIR}}/mhs-embed/scripts/mhs-patch-xffi.py
    COMMENT "Creating mhs_repl.c"
    VERBATIM
)

add_executable({project_name}
    ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_repl.c
    ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_main.c
    ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_ffi_wrappers.c
    ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_ffi.c
    ${{MHS_RUNTIME}}/eval.c
)

target_include_directories({project_name} PRIVATE
    ${{MHS_RUNTIME}}
    ${{CMAKE_CURRENT_SOURCE_DIR}}
)

if(WIN32)
    target_include_directories({project_name} PRIVATE ${{MHS_RUNTIME}}/windows)
else()
    target_include_directories({project_name} PRIVATE ${{MHS_RUNTIME}}/unix)
    target_link_libraries({project_name} PRIVATE m)
endif()

# TODO: Link your libraries
# target_link_libraries({project_name} PRIVATE your_library)

# ============================================
# Standalone variants (Unix only)
# ============================================

if(NOT WIN32)

set(ZSTD_DIR ${{CMAKE_SOURCE_DIR}}/thirdparty/zstd-1.5.7)

# Patch mhs.c for standalone
add_custom_command(
    OUTPUT ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_standalone.c
    COMMAND ${{Python3_EXECUTABLE}} ${{CMAKE_SOURCE_DIR}}/mhs-embed/scripts/mhs-patch-xffi.py
        ${{MHS_DIR}}/generated/mhs.c
        ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_standalone.c
    DEPENDS ${{MHS_DIR}}/generated/mhs.c
    COMMENT "Creating mhs_standalone.c"
    VERBATIM
)

# Patch eval.c for VFS
add_custom_command(
    OUTPUT ${{CMAKE_CURRENT_BINARY_DIR}}/eval_vfs.c
    COMMAND ${{Python3_EXECUTABLE}} ${{CMAKE_SOURCE_DIR}}/mhs-embed/scripts/mhs-patch-eval.py
        ${{MHS_RUNTIME}}/eval.c
        ${{CMAKE_CURRENT_BINARY_DIR}}/eval_vfs.c
    DEPENDS ${{MHS_RUNTIME}}/eval.c
    COMMENT "Creating eval_vfs.c"
    VERBATIM
)

# Build mhs-embed tool
set(MHS_EMBED ${{CMAKE_BINARY_DIR}}/mhs-embed)
add_custom_command(
    OUTPUT ${{MHS_EMBED}}
    COMMAND ${{CMAKE_C_COMPILER}} -O2
        -o ${{MHS_EMBED}}
        ${{CMAKE_SOURCE_DIR}}/mhs-embed/scripts/mhs-embed.c
        ${{ZSTD_DIR}}/zstd.c
        -I${{ZSTD_DIR}}
        -lpthread
    DEPENDS ${{CMAKE_SOURCE_DIR}}/mhs-embed/scripts/mhs-embed.c
    COMMENT "Building mhs-embed tool"
    VERBATIM
)

# Generate embedded header (uncompressed source)
set(EMBEDDED_HEADER ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_embedded_libs.h)
add_custom_command(
    OUTPUT ${{EMBEDDED_HEADER}}
    COMMAND ${{MHS_EMBED}}
        ${{EMBEDDED_HEADER}}
        ${{MHS_LIB}}
        ${{CMAKE_CURRENT_SOURCE_DIR}}/lib
        --no-compress
        --runtime ${{MHS_RUNTIME}}
        --header ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_ffi.h
        # TODO: Add --lib flags for your static libraries
    DEPENDS ${{MHS_EMBED}}
    COMMENT "Generating embedded header"
    VERBATIM
)

# Standalone executable
add_executable({project_name}-standalone
    ${{CMAKE_CURRENT_BINARY_DIR}}/mhs_standalone.c
    ${{CMAKE_CURRENT_BINARY_DIR}}/eval_vfs.c
    ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_standalone_main.c
    ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_ffi_wrappers.c
    ${{CMAKE_CURRENT_SOURCE_DIR}}/{project_name}_ffi.c
    ${{MHS_EMBED_DIR}}/vfs.c
    ${{MHS_EMBED_DIR}}/mhs_ffi_override.c
    ${{EMBEDDED_HEADER}}
)

target_include_directories({project_name}-standalone PRIVATE
    ${{MHS_RUNTIME}}
    ${{MHS_RUNTIME}}/unix
    ${{CMAKE_CURRENT_SOURCE_DIR}}
    ${{CMAKE_CURRENT_BINARY_DIR}}
    ${{MHS_EMBED_DIR}}
)

target_compile_definitions({project_name}-standalone PRIVATE
    VFS_EMBEDDED_HEADER=mhs_embedded_libs.h
)

target_link_libraries({project_name}-standalone PRIVATE m)

# TODO: Link your libraries
# target_link_libraries({project_name}-standalone PRIVATE your_library)

endif() # NOT WIN32

# ============================================
# Installation
# ============================================

install(TARGETS {project_name}
    RUNTIME DESTINATION bin
)

install(DIRECTORY ${{CMAKE_CURRENT_SOURCE_DIR}}/lib/
    DESTINATION share/{project_name}/lib
    FILES_MATCHING PATTERN "*.hs"
)
'''


def create_project(project_name: str, output_dir: Path, no_cmake: bool = False) -> None:
    """Create all project files."""

    # Validate project name
    if not project_name.replace('_', '').isalnum():
        print(f"Error: Project name must be alphanumeric with underscores: {project_name}",
              file=sys.stderr)
        sys.exit(1)

    if project_name[0].isdigit():
        print(f"Error: Project name cannot start with a digit: {project_name}",
              file=sys.stderr)
        sys.exit(1)

    camel = to_camel_case(project_name)

    # Create directories
    output_dir.mkdir(parents=True, exist_ok=True)
    lib_dir = output_dir / "lib"
    lib_dir.mkdir(exist_ok=True)
    examples_dir = output_dir / "examples"
    examples_dir.mkdir(exist_ok=True)

    # Generate files
    files = [
        (output_dir / f"{project_name}_ffi.h", generate_ffi_header(project_name)),
        (output_dir / f"{project_name}_ffi.c", generate_ffi_impl(project_name)),
        (output_dir / f"{project_name}_ffi_wrappers.c", generate_ffi_wrappers(project_name)),
        (output_dir / f"{project_name}_main.c", generate_repl_main(project_name)),
        (output_dir / f"{project_name}_standalone_main.c", generate_standalone_main(project_name)),
        (lib_dir / f"{camel}.hs", generate_haskell_module(project_name)),
        (examples_dir / "Main.hs", generate_example_main(project_name)),
    ]

    if not no_cmake:
        files.append((output_dir / "CMakeLists.txt", generate_cmake(project_name)))

    for path, content in files:
        path.write_text(content)
        print(f"  Created: {path}")

    print(f"\nProject '{project_name}' created in {output_dir}")
    print(f"\nNext steps:")
    print(f"  1. Edit {project_name}_ffi.h and {project_name}_ffi.c with your C API")
    print(f"  2. Update {project_name}_ffi_wrappers.c to match your API")
    print(f"  3. Update lib/{camel}.hs with Haskell bindings")
    print(f"  4. Add project to main CMakeLists.txt: add_subdirectory(projects/{project_name})")
    print(f"  5. Build: cmake -B build && cmake --build build")
    print(f"  6. Run: ./build/{project_name}")


def main():
    parser = argparse.ArgumentParser(
        description="Initialize a new MicroHs project with FFI support",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s my_audio                           Create in projects/my_audio/
  %(prog)s my_audio --output-dir libs/audio   Create in libs/audio/
  %(prog)s my_audio --no-cmake                Skip CMakeLists.txt generation
        """
    )

    parser.add_argument(
        "project_name",
        help="Project name (snake_case, e.g., 'my_project')"
    )

    parser.add_argument(
        "--output-dir", "-o",
        type=Path,
        help="Output directory (default: projects/<project_name>)"
    )

    parser.add_argument(
        "--no-cmake",
        action="store_true",
        help="Don't generate CMakeLists.txt"
    )

    args = parser.parse_args()

    # Determine output directory
    if args.output_dir:
        output_dir = args.output_dir
    else:
        # Find project root (look for CMakeLists.txt or .git)
        script_dir = Path(__file__).parent
        project_root = script_dir.parent
        output_dir = project_root / "projects" / args.project_name

    print(f"Initializing MicroHs project: {args.project_name}")
    print(f"Output directory: {output_dir}")
    print()

    create_project(args.project_name, output_dir, args.no_cmake)


if __name__ == "__main__":
    main()
